<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GBG Infinite Runner</title>
<style>
body { margin:0; font-family:Arial,sans-serif; background:#111; color:white; overflow:hidden; }
header { position:fixed; top:0; width:100%; background:#000c; padding:15px; display:flex; justify-content:space-between; align-items:center; z-index:1000; }
#startBtn { padding:10px 20px; font-size:18px; border:none; border-radius:10px; cursor:pointer; background:linear-gradient(to right, red, orange, yellow, green, cyan, blue, violet); color:white; }
canvas { display:block; margin:90px auto 20px auto; background:#111; border:3px solid #0ff; border-radius:12px; }
.controls { position:fixed; bottom:20px; width:100%; display:flex; justify-content:center; gap:20px; }
.controls button { padding:15px 20px; font-size:18px; border:none; border-radius:12px; cursor:pointer; background:linear-gradient(to right, red, orange, yellow, green, cyan, blue, violet); color:white; }
#commandPrompt { position:fixed; left:10px; top:80px; width:300px; height:400px; background:#000c; overflow-y:auto; padding:10px; border-radius:12px; font-family:monospace; }
#commandPrompt input { width:90%; padding:5px; margin-top:10px; border-radius:5px; border:none; }
#commandLog { margin-top:10px; max-height:250px; overflow-y:auto; font-size:14px; }
#leaderboard { position:fixed; right:10px; top:80px; width:250px; height:400px; background:#000c; overflow-y:auto; padding:10px; border-radius:12px; }
#gameOverPopup { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%) scale(0); background:#000c; padding:30px; border-radius:15px; text-align:center; transition:0.3s; }
#gameOverPopup.show { transform:translate(-50%,-50%) scale(1); }
#gameOverPopup button { padding:10px 20px; margin-top:15px; border:none; border-radius:10px; cursor:pointer; background:linear-gradient(to right, red, orange, yellow, green, cyan, blue, violet); color:white; }
.highest { color:#0ff; font-weight:bold; }
</style>
</head>
<body>

<header>
  <div>GBG Infinite Runner</div>
  <button id="startBtn">Start Game</button>
</header>

<div id="commandPrompt">
  <p>// GBG Commands:</p>
  <input type="text" id="cmdInput" placeholder="Type command and press Enter">
  <div id="commandLog"></div>
</div>

<div id="leaderboard">
  <h3>Leaderboard</h3>
  <ol id="scoreList"></ol>
</div>

<canvas id="game" width="800" height="400"></canvas>

<div class="controls">
  <button id="leftBtn">⬅️</button>
  <button id="rightBtn">➡️</button>
</div>

<div id="gameOverPopup">
  <h2>Game Over!</h2>
  <p id="finalScore"></p>
  <button onclick="restartGame()">Restart</button>
</div>

<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');

let gameStarted=false;
let speed=5, scrollSpeed=2, enemySpeed=2;
let score=0;
let coins=[], enemies=[];
let coinSize=20, enemySize=40;
let player={x:375,y:320,w:50,h:50};
let keys={};
let highScores=JSON.parse(localStorage.getItem('highScores'))||[];
let totalCoins=parseInt(localStorage.getItem('totalCoins'))||0;
const commandLogDiv=document.getElementById('commandLog');
let playerName=localStorage.getItem('playerName')||null;

// Start game
function startGame(){
  if(!playerName){
    let nameValid=false;
    while(!nameValid){
      let name=prompt('Enter your unique name:')||'Player';
      if(highScores.find(h=>h.name===name)){
        alert('Name already taken! Enter a different name.');
      }else{
        playerName=name; localStorage.setItem('playerName', playerName); nameValid=true;
      }
    }
  }
  gameStarted=true;
  score=0; coins=[]; enemies=[];
  player.x=375; player.y=320;
  document.getElementById('startBtn').style.display='none';
  spawnInitialCoins();
  spawnInitialEnemies();
  renderLeaderboard();
  requestAnimationFrame(gameLoop);
}

// Spawn coins/enemies
function spawnInitialCoins(){ for(let i=0;i<10;i++) spawnCoin(-Math.random()*canvas.height); }
function spawnCoin(y){ let x=Math.random()*(canvas.width-coinSize); if(y===undefined)y=-coinSize; coins.push({x,y}); }
function spawnInitialEnemies(){ for(let i=0;i<5;i++) spawnEnemy(-Math.random()*canvas.height*2); }
function spawnEnemy(y){ let x=Math.random()*(canvas.width-enemySize); if(y===undefined)y=-enemySize; enemies.push({x,y}); }

// Draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='red'; ctx.fillRect(player.x,player.y,player.w,player.h);
  ctx.fillStyle='yellow'; coins.forEach(c=>ctx.fillRect(c.x,c.y,coinSize,coinSize));
  ctx.fillStyle='green'; enemies.forEach(e=>ctx.fillRect(e.x,e.y,enemySize,enemySize));
  ctx.fillStyle='white'; ctx.font='20px Arial'; ctx.fillText('Score: '+score,10,30);
}

// Update
function update(){
  if(keys['ArrowLeft']) player.x-=speed;
  if(keys['ArrowRight']) player.x+=speed;
  if(player.x<0) player.x=0;
  if(player.x+player.w>canvas.width) player.x=canvas.width-player.w;

  coins.forEach(c=>c.y+=scrollSpeed);
  enemies.forEach(e=>e.y+=enemySpeed);

  coins.forEach((c,i)=>{ if(c.y>canvas.height){ coins.splice(i,1); spawnCoin(); } });
  enemies.forEach((e,i)=>{ if(e.y>canvas.height){ enemies.splice(i,1); spawnEnemy(); } });

  coins.forEach((c,i)=>{ 
    if(player.x<c.x+coinSize && player.x+player.w>c.x && player.y<c.y+coinSize && player.y+player.h>c.y){
      coins.splice(i,1); score++; totalCoins++; spawnCoin(); renderLeaderboard(); updateTotalCoins(); 
    } 
  });

  enemies.forEach(e=>{
    if(player.x<e.x+enemySize && player.x+player.w>e.x && player.y<e.y+enemySize && player.y+player.h>e.y){
      endGame();
    }
  });
}

// Update total coins in localStorage
function updateTotalCoins(){
  localStorage.setItem('totalCoins', totalCoins);
}

// Game loop
function gameLoop(){ if(!gameStarted) return; update(); draw(); requestAnimationFrame(gameLoop); }

// Game over
function endGame(){
  gameStarted=false;
  document.getElementById('finalScore').innerText='Coins collected this run: '+score;
  document.getElementById('gameOverPopup').classList.add('show');

  // Cumulative score
  let existing=highScores.find(h=>h.name===playerName);
  if(existing){ existing.score += score; } 
  else{ highScores.push({name:playerName, score:score}); }
  highScores.sort((a,b)=>b.score-a.score);
  localStorage.setItem('highScores',JSON.stringify(highScores));
  renderLeaderboard();
}

// Restart
function restartGame(){ document.getElementById('gameOverPopup').classList.remove('show'); startGame(); }

// Leaderboard
function renderLeaderboard(){
  const list=document.getElementById('scoreList'); list.innerHTML='';
  let maxScore=highScores.reduce((max,h)=>h.score>max?h.score:max,0);
  highScores.slice(0,10).forEach(h=>{
    let li=document.createElement('li');
    li.innerText=h.name+' - '+h.score;
    if(h.score===maxScore) li.classList.add('highest');
    list.appendChild(li);
  });
}

// Controls
window.addEventListener('keydown',e=>keys[e.key]=true);
window.addEventListener('keyup',e=>keys[e.key]=false);
document.getElementById('leftBtn').addEventListener('touchstart',()=>keys['ArrowLeft']=true);
document.getElementById('leftBtn').addEventListener('touchend',()=>keys['ArrowLeft']=false);
document.getElementById('rightBtn').addEventListener('touchstart',()=>keys['ArrowRight']=true);
document.getElementById('rightBtn').addEventListener('touchend',()=>keys['ArrowRight']=false);

// Commands
document.getElementById('cmdInput').addEventListener('keydown',function(e){
  if(e.key==='Enter'){ executeCommand(this.value); this.value=''; }
});
function executeCommand(cmd){
  if(!cmd) return; logCommand(cmd);
  const parts=cmd.trim().split(' ');
  switch(parts[0]){
    case 'gbg.speed': let sp=parseInt(parts[1]); if(!isNaN(sp)){ speed=sp; scrollSpeed=sp/2; } break;
    case 'gbg.scroll': let sc=parseInt(parts[1]); if(!isNaN(sc)) scrollSpeed=sc; break;
    case 'gbg.coin': let c=parseInt(parts[1]); if(!isNaN(c)) for(let i=0;i<c;i++) spawnCoin(); break;
    case 'gbg.enemy': let e=parseInt(parts[1]); if(!isNaN(e)) for(let i=0;i<e;i++) spawnEnemy(); break;
    case 'gbg.cd_speed': let x=parseInt(parts[1]); if(!isNaN(x)){ speed=x; scrollSpeed=x/2; } break;
    case 'gbg.maxCoins': 
      let maxC=parseInt(parts[1])||50; maxC=Math.min(maxC,1000); 
      for(let i=0;i<maxC;i++) spawnCoin(); 
    break;
    case 'gbg.enemySpeed': let es=parseFloat(parts[1]); if(!isNaN(es)) enemySpeed=es; break;
    case 'gbg.reset': restartGame(); break;
    default: logCommand('Unknown command'); break;
  }
}
function logCommand(text){
  const p=document.createElement('p'); p.innerText=text; commandLogDiv.appendChild(p); commandLogDiv.scrollTop=commandLogDiv.scrollHeight;
}

// Start button listener
document.getElementById('startBtn').addEventListener('click', startGame);
</script>
</body>
</html>
